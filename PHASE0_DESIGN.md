# PHASE 0 â€” DESIGN

## 1. Problem Statement

Fluid diagnostics are inherently complex because they involve correlating state across multiple asynchronous systems: Kubernetes core resources (Pods, PVCs, Nodes), Fluid Custom Resources (Datasets, Runtimes), and the underlying distributed storage systems (Alluxio, JuiceFS, etc.).

Operators and developers struggle to interpret failures for several reasons:
- **Disconnect between layers:** A Pod Pending state might be due to a PVC issue, which in turn is due to a Dataset not being bound, which is due to a Runtime not being ready. Humans struggle to traverse this graph manually.
- **Log overload:** Relevant signals are buried in a sea of events and logs.
- **Ambiguous symptoms:** "Application Pod Pending" can mean a thousand different things.
- **Reasoning gap:** There is a fundamental difference between *observation* (e.g., "Pod is Pending"), *diagnosis* (e.g., "PVC is Unbound"), and *reasoning* (e.g., "The PVC is unbound because the Runtime failed to provision due to insufficient memory on the specific node pool").

This project aims to bridge the gap between raw diagnostic data and actionable reasoning without introducing heavyweight dependencies or non-deterministic AI hallucinations.

## 2. Explicit Non-Goals

To maintain focus, security, and portability, this project explicitly adheres to the following non-goals:

- **No Kubernetes API Usage:** This library must not import `client-go` or interact with a live cluster. It operates solely on static, serialized context.
- **No Log Collection:** Data gathering is the responsibility of upstream tools (e.g., `fluid-diagnose-bundler`, `fluidctl`).
- **No Cluster Mutations:** The engine is read-only and will never attempt to "fix" the cluster.
- **No "Auto-fix":** Automated remediation is out of scope.
- **No CLI:** This is a pure Go library. CLI functionality belongs in `fluidctl` or other consumer tools.

## 3. Input Contract (Authoritative)

The engine accepts a single, structured input representing a snapshot of the relevant cluster state. This structure is assumed to be generated by `fluid-diagnose-bundler` or `fluidctl diagnose --output json`.

```go
type DiagnosticContext struct {
    Summary   Summary
    Graph     ResourceGraph
    Findings  []FailureHint
    Events    []Event
    Logs      map[string]string
    Metadata  Metadata
}
```

- **Summary:** High-level counts and status.
- **Graph:** A directional graph representing dependencies (e.g., Pod -> PVC -> Dataset -> Runtime).
- **Findings:** Raw, uninterpreted observations collected by the bundler.
- **Events:** Relevant Kubernetes events.
- **Logs:** Key logs captured from controller or runtime pods.
- **Metadata:** Context about the collection (time, cluster version, etc.).

## 4. Output Contract

The engine produces a deterministic reasoning output, ranking hypotheses by confidence.

```go
type Hypothesis struct {
    Rank        int       // 1 is the most likely
    Confidence  float64   // 0.0 to 1.0 (heuristic, not probabilistic)
    Component   string    // e.g., "Runtime", "Dataset", "Node"
    Issue       string    // Brief description of the root cause
    Evidence    []string  // IDs or descriptions of the specific observations used
    Suggestion  string    // Actionable step for the user
}

type DiagnosisResult struct {
    Hypotheses  []Hypothesis
    GeneratedAt time.Time
    Engine      string    // "rule-based"
}
```

## 5. Reasoning Principles

- **Deterministic Ordering:** Given the exact same input, result ordering must be identical.
- **Evidence-Backed Reasoning:** Every hypothesis must cite specific evidence (Event ID, Condition Status, etc.) found in the input.
- **Confidence Scores:** Scores are assigned based on static heuristics (e.g., a specific error message is stronger evidence than a generic status), not ML probability.
- **No Hallucination:** If data is missing, the engine yields "Unknown" or low confidence rather than guessing.
- **No Certainty Claims:** All outputs are "Hypotheses," acknowledging that the snapshot might be incomplete.

## 6. Future AI Extension (Design Only)

*Note: This section is for design intent only and is not implemented in Phase 1.*

To extend this engine with LLM capabilities in the future:
- **LLM Adapter Interface:** Defined interface to accept `DiagnosticContext` and return structured `Hypothesis`.
- **Prompt Boundaries:** Prompts must be strictly scoped to the provided context to prevent external knowledge hallucination.
- **Grounding Rules:** The LLM would be required to output citations (Evidence IDs) from the context, which the deterministic engine would ideally verify.
